/************************************************************************
 *
 * Licensed Materials - Property of IBM.
 * (C) Copyright IBM Corporation 2003, 2012.  All Rights Reserved.
 * U.S. Government Users Restricted Rights:
 * Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 *
 ************************************************************************/

package org.openoffice.test.common;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URL;
import java.net.URLConnection;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Properties;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import org.w3c.dom.Document;


/**
 * Utilities related to the file system
 *
 */
public class FileUtil {
	 
	private final static DateFormat FILENAME_FORMAT = new SimpleDateFormat("yyMMddHHmm");
	
	private FileUtil(){
		
	}
	
	public static Document parseXML(String path) {
		try {
			DocumentBuilderFactory dbfac = DocumentBuilderFactory.newInstance();
			dbfac.setNamespaceAware(true);
			DocumentBuilder docBuilder = dbfac.newDocumentBuilder();
			return docBuilder.parse(path);
		} catch (Exception e) {
			return null;
		}
	}
	
	public static String getStringByXPath(String xml, String xpathStr) {
		Document doc = parseXML(xml);
		if (doc == null)
			return null;
	
	    try {
	    	XPathFactory factory = XPathFactory.newInstance();
			XPath xpath = factory.newXPath();
			XPathExpression expr = xpath.compile(xpathStr);
			return (String) expr.evaluate(doc);
		} catch (XPathExpressionException e) {
			e.printStackTrace();
			return null;
		}


	}

	
	
	/**
	 * Update the given property in a properties file
	 * @param file the properties file path
	 * @param key the key
	 * @param value the value
	 */
	public static void updateProperty(String file, String key, String value) {
		Properties map = new Properties();
		map.put(key, value);
		updateProperty(file, map);
	}
	
	/**
	 * Update the given properties in a properties file
	 * @param file the properties file path
	 * @param props properties updated
	 */
	public static void updateProperty(String file, Properties props) {
		Properties properties = loadProperties(file);
		properties.putAll(props);
		storeProperties(file, properties);
	}
	
	/**
	 * Load a properties file to Properties class
	 * @param file the properties file path
	 * @return
	 */
	public static Properties loadProperties(String file) {
		Properties properties = new Properties();
		FileInputStream fis = null;
		try {
			fis = new FileInputStream(file);
			properties.load(fis);
		} catch (IOException e) {
			//System.out.println("Can't read properties file.");
		} finally {
			if (fis != null) {
				try {
					fis.close();
				} catch (IOException e) {
					// ignore
				}
			}
		}
		
		return properties;
	}
	
	/**
	 * Store properties into a file
	 * @param file the properties file path
	 * @param properties the properties to be stored
	 */
	public static void storeProperties(String file, Properties properties) {
		FileOutputStream fos = null;
		try {
			fos = new FileOutputStream(file);
			properties.store(fos, "Generated By PropertyFileUtils");
		} catch (IOException e) {
			throw new RuntimeException(e);
		} finally {
			if (fos != null) {
				try {
					fos.close();
				} catch (IOException e) {
					// ignore
				}
			}
		}
	}
	
	
	
	/**
	 * Delete a property in a properties file
	 * @param file the properties file path
	 * @param key the key to be deleted
	 */
	public static void deleteProperty(String file, String key) {
		Properties properties = loadProperties(file);
		properties.remove(key);
		storeProperties(file, properties);
	}

	/**
	 * Load a file as string
	 * @param file the file path
	 * @return 
	 */
	public static String readFileAsString(String file) {
		return readFileAsString(new File(file));
	}
	
	/**
	 * Load a file as string
	 * @param file the file path
	 * @return 
	 */
	public static String readFileAsString(File file) {
		StringBuffer strBuffer = new StringBuffer(10240);
		BufferedReader reader = null;
		try {
			reader = new BufferedReader(new FileReader(file));
			char[] buf = new char[1024];
			int count = 0;
			while ((count = reader.read(buf)) != -1) {
				strBuffer.append(buf, 0, count);
			}
		} catch (IOException e) {
		} finally {
			if (reader != null)
				try {
					reader.close();
				} catch (IOException e) {
					// ignore
				}
		}

		return strBuffer.toString();
	}
	
	/**
	 * Find the first file matching the given name.
	 * @param dir The directory to search in
	 * @param name Regular Expression to match the file name
	 * @return
	 */
	public static File findFile(File dir, String name) {
		if (!dir.isDirectory())
			return null;
		File[] files = dir.listFiles();
		for (int i = 0; i < files.length; i++) {
			if (files[i].isDirectory()) {
				File ret = findFile(files[i], name);
				if (ret != null)
					return ret;
			} else if (files[i].getName().matches(name)) {
				return files[i];
			}
		}
		
		return null;
	}
	
	/**
	 * Find the last file matching the given name.
	 * @param dir The directory to search in
	 * @param name Regular Expression to match the file name
	 * @return
	 */
	public static File findLastFile(File dir, String name) {
		if (!dir.isDirectory())
			return null;
		File[] files = dir.listFiles();
		File file = null;
		for (int i = 0; i < files.length; i++) {
			if (files[i].isDirectory()) {
				File ret = findFile(files[i], name);
				if (ret != null)
					file = ret;
			} else if (files[i].getName().matches(name)) {
				file = files[i];
			}
		}
		
		return file;
	}
	
	/**
	 * find the first file matching the given name.
	 * @param dirs The directories to search in. Use ';' separate each directory.
	 * @param name Regular Expression to match the file name
	 * @return
	 */
	public static File findFile(String dirs, String name) {
		String[] directories = dirs.split(";");
		for (String s : directories) {
			File dir = new File(s);
			if (!dir.exists())
				continue;
			File file = findFile(dir, name);
			if (file != null)
				return file;
		}
		
		return null;
	}
	
	
	/**
	 * find the last file matching the given name.
	 * @param dirs The directories to search in. Use ';' separate each directory.
	 * @param name Regular Expression to match the file name
	 * @return
	 */
	public static File findLastFile(String dirs, String name) {
		String[] directories = dirs.split(";");
		for (String s : directories) {
			File dir = new File(s);
			if (!dir.exists())
				continue;
			File file = findLastFile(dir, name);
			if (file != null)
				return file;
		}
		
		return null;
	}
	
	/**
	 * find the directory matching the given name.
	 * @param dir The directory to search in
	 * @param name Regular Expression to match the file name
	 * @return
	 */
	public static File findDir(String dir, String dirName) {
		File[] files = new File(dir).listFiles();
		for (int i = 0; i < files.length; i++) {
			if (!files[i].isDirectory()) {
				File ret = findFile(files[i], dirName);
				if (ret != null)
					return ret;
			} else if (files[i].getName().matches(dirName)) {
				return files[i];
			}
		}
		
		return null;
	}
	

	public static void writeStringToFile(String filePath, String contents) {
		FileWriter writer = null;
		try {
			File file = new File(filePath);
			file.getParentFile().mkdirs();
			writer = new FileWriter(file);
			if (contents != null)
				writer.write(contents);
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			if (writer != null)
				try {
					writer.close();
				} catch (IOException e) {
				}
		}
	}
	
	/**
	 * Appeand a string to the tail of a file
	 * @param file
	 * @param contents
	 */
	public static void appendStringToFile(String file, String contents) {
		FileWriter writer = null;
		try {
			writer = new FileWriter(file, true);
			writer.write(contents);
		} catch (IOException e) {
			System.out.println("Warning:" + e.getMessage());
		} finally {
			if (writer != null)
				try {
					writer.close();
				} catch (IOException e) {
				}
		}
	}
	
	/**
	 * Replace string in the file use regular expression
	 * @param file
	 * @param expr
	 * @param substitute
	 */
	public static void replace(String file, String expr, String substitute) {
		String str = readFileAsString(file);
		str = str.replaceAll(expr, substitute);
		writeStringToFile(file, str);
	}
	
    /**
     * Recursively copy all files in the source dir into the destination dir
     * @param fromDirName the source dir 
     * @param toDirName the destination dir
     * @return
     */
    public static boolean copyDir(String fromDirName, String toDirName)  {
    	return copyDir(new File(fromDirName), new File(toDirName), true);
    }
    
    /**
     * Copy all files in the source dir into the destination dir
     * @param fromDir
     * @param toDir
     * @param recursive
     * @return
     */
    public static boolean copyDir(File fromDir, File toDir, boolean recursive) {
    	if (!fromDir.exists() || !fromDir.isDirectory()) {
    		System.err.println("The source dir doesn't exist, or isn't dir.");
    		return false;
    	}
    	if (toDir.exists() && !toDir.isDirectory())
    		return false;
    	boolean result = true;
    	toDir.mkdirs();
    	File[] files = fromDir.listFiles();
    	for (int i = 0; i < files.length; i++) {
    		if (files[i].isDirectory() && recursive)
    			result &= copyDir(files[i], new File(toDir, files[i].getName()), true);
    		else
    			result &= copyFile(files[i], toDir);
    	}
    	
    	return result;
    }
    
    /**
     * Copy a file
     * @param fromFile
     * @param toFile
     * @return
     */
    public static boolean copyFile(File fromFile, File toFile) {
    	 if (!fromFile.exists() || !fromFile.isFile() || !fromFile.canRead()) {
         	System.err.println(fromFile.getAbsolutePath() + "doesn't exist, or isn't file, or can't be read");
         	return false;
         }
      
         if (toFile.isDirectory())
           toFile = new File(toFile, fromFile.getName());

         FileInputStream from = null;
         FileOutputStream to = null;
         try {
           from = new FileInputStream(fromFile);
           File p = toFile.getParentFile();
           if (p != null && !p.exists())
        	   p.mkdirs();
           to = new FileOutputStream(toFile);
           byte[] buffer = new byte[4096];
           int bytesRead;
           while ((bytesRead = from.read(buffer)) != -1)
             to.write(buffer, 0, bytesRead);
           
           return true;
         } catch (IOException e) {
         	//Can't copy
         	e.printStackTrace();
         	return false;
         } finally {
           if (from != null)
             try {
               from.close();
             } catch (IOException e) {
             }
           if (to != null)
             try {
               to.close();
             } catch (IOException e) {
             }
         }
    }
    
    /**
     * Copy a file
     * @param fromFileName
     * @param toFileName
     * @return
     */
    public static boolean copyFile(String fromFileName, String toFileName) {
    	return copyFile(new File(fromFileName), new File(toFileName));
    }
    
    /**
     * Copy all the files under fromDirName to toDirName
     * @param fromDirName
     * @param toDirName
     * @return
     */
    public static boolean copyFiles(String fromDirName, String toDirName) {
    	boolean res = true;
    	
    	File fromDir = new File(fromDirName);
    	if (!fromDir.exists() || !fromDir.isDirectory() || !fromDir.canRead()) {
         	System.err.println(fromDir.getAbsolutePath() + "doesn't exist, or isn't file, or can't be read");
         	return false;
         }
    	File [] files = fromDir.listFiles();
    	for(int i=0; i<files.length; i++){
    		if(files[i].isDirectory()){
    			res = res && copyDir(fromDirName + "/" + files[i].getName(), toDirName + "/" + files[i].getName());
    		}
    		else 
    			res = res && copyFile(fromDirName + "/" + files[i].getName(), toDirName + "/" + files[i].getName());
    	}
    	return res;
    }
    
    /**
     * Delete a file
     * @param file
     * @return
     */
    public static boolean deleteFile(File path) {
    	if (!path.exists())
    		return true;
    	
		if (path.isDirectory()) {
			File[] files = path.listFiles();
			for (int i = 0; i < files.length; i++) {
				if (files[i].isDirectory()) {
					deleteFile(files[i]);
				} else {
					files[i].delete();
				}
			}
		}
		
		return path.delete();
	}
    
    public static boolean deleteFile(String path) {
		return deleteFile(new File(path));
	}
    
    public static boolean fileExists(String file) {
    	return new File(file).exists();
    }
   
    /**
     * Get the extension name of a file
     * @param file
     * @return
     */
	public static String getFileExtName(String file) {
		if (file == null)
			return null;
		int i = file.lastIndexOf('.');
		if (i < 0 && i >= file.length() - 1)
			return null;
		return file.substring(i+1);
	}
	 /**
     * Get the file's size
     * @param file
     * @return KB
     */
	public static long getFileSize(String filePath){
		long totalSize = 0;
		FileInputStream f = null;
		File file = new File(filePath);
		
		try {
			f = new FileInputStream(file);
			totalSize = f.available();
			f.close();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return totalSize/1000;
	}

	/**
     * Get the folder's size
     * @param folder's path
     * @return Kb
     */
	public static long getFolderSize(String dir){
		long totalSize = 0;
		File[] files = new File(dir).listFiles();
		
		for(int i=0; i<files.length; i++){
			if(files[i].isDirectory())
				totalSize = totalSize + getFolderSize(files[i].getAbsolutePath())*1000;
			else
				totalSize = totalSize + files[i].length();
		}
		
		return totalSize/1000;
	}
	
	/**
     * unzip file to the unzipToLoc
     * @param folder's path
     * @return Kb
     */
	public static void unzipFile(String unzipfile, String unzipDest){
		    try {
		      File dest = new File(unzipDest); 
		      ZipInputStream zin = new ZipInputStream(new FileInputStream(unzipfile));
		      ZipEntry entry;
		      //Create folder
		      while ( (entry = zin.getNextEntry()) != null){
		        if (entry.isDirectory()) {
		          File directory = new File(dest, entry.getName());
		          if (!directory.exists())
		            if (!directory.mkdirs())
		              System.exit(0);
		          zin.closeEntry();
		        }
		        if (!entry.isDirectory()) {
		          File myFile = new File(entry.getName());
		          FileOutputStream fout = new FileOutputStream(unzipDest + "/" + myFile.getPath());
		          DataOutputStream dout = new DataOutputStream(fout);
		          byte[] b = new byte[1024];
		          int len = 0;
		          while ( (len = zin.read(b)) != -1) {
		            dout.write(b, 0, len);
		          }
		          dout.close();
		          fout.close();
		          zin.closeEntry();
		        }
		      }
		    }
		    catch (IOException e) {
		      e.printStackTrace();
		      System.out.println(e);
		    }
	}
	
	public static File getUniqueFile(File dir, String prefix, String suffix) {
		String name = prefix + "." + FILENAME_FORMAT.format(new Date()) + ".";
		for (int i = 0; i < Integer.MAX_VALUE; i++) {
			File file = new File(dir, name + i + suffix);
			if (!file.exists()) {
				return file;
			}
		}
		
		return null;
	}
	
	public static File getUniqueFile(String dir, String prefix, String suffix) {
		return getUniqueFile(new File(dir), prefix, suffix);
	}
	
	
	public static File download(String urlString, File output) {
		InputStream in = null;
		OutputStream out = null;
		System.out.println("[Vclauto] Download '" + urlString + "'");
		try {
			URL url = new URL(urlString);
			URLConnection urlConnection = url.openConnection();
			int totalSize = urlConnection.getContentLength();
			in = urlConnection.getInputStream();
			if (output.isDirectory()) {
				output = new File(output, url.getPath());
				output.getParentFile().mkdirs();
			}
			out = new FileOutputStream(output);

			byte[] buffer = new byte[1024 * 100]; // 100k
			int count = 0;
			int totalCount = 0;
			int progress = 0;
			while ((count = in.read(buffer)) > 0) {
				out.write(buffer, 0, count);
				totalCount += count;
				
				if (totalSize > 0) {
					int nowProgress = totalCount * 10 / totalSize;
					if (nowProgress > progress) {
						progress = nowProgress;
						System.out.print(".");
					}
				}
				
			}
			System.out.println("Done!");
			return output;
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println("Error!");
			return null;
		} finally {
			if (in != null)
				try {
					in.close();
				} catch (IOException e) {
				}
			if (out != null)
				try {
					out.close();
				} catch (IOException e) {

				}
		}
	}

}
