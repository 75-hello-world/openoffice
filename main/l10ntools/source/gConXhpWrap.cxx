/**************************************************************
 * 
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * 
 *************************************************************/
#include "gConXhp.hxx"
#include <algorithm>
#include <iostream>
#include <fstream>
#include <cstdlib>



/*****************************************************************************
 *********************   G C O N X H P W R A P . C X X   *********************
 *****************************************************************************
 * This includes the c code generated by flex
 *****************************************************************************/



/************   I N T E R F A C E   I M P L E M E N T A T I O N   ************/
lang_container::lang_container(const std::string& sLang, const std::string& sFileName)
{
  std::string x;

  x= sLang;
  x= sFileName;
  // JIX: implement file open
  // JIX: implement lang tag
}



/************   I N T E R F A C E   I M P L E M E N T A T I O N   ************/
lang_container::lang_container()
{
}



/************   I N T E R F A C E   I M P L E M E N T A T I O N   ************/
lang_container::~lang_container()
{
  // JIX: implement close file
}



/************   I N T E R F A C E   I M P L E M E N T A T I O N   ************/
convert_xhp::convert_xhp(l10nMem& crMemory)
                        : convert_gen_impl(crMemory),
                          meExpectValue(VALUE_NOT_USED)
{
  // xhp files are written through a local routine
  mbLoadMode = true;
}



/************   I N T E R F A C E   I M P L E M E N T A T I O N   ************/
convert_xhp::~convert_xhp()
{
}



/**********************   I M P L E M E N T A T I O N   **********************/
namespace XhpWrap
{
#define IMPLptr convert_gen_impl::mcImpl
#define LOCptr ((convert_xhp *)convert_gen_impl::mcImpl)
#include "gConXhp_yy.c"
}


/**********************   I M P L E M E N T A T I O N   **********************/
void convert_xhp::execute()
{
  std::string sLang;
  std::string sFile = msTargetPath+msSourceFile;

  // prepare list with languages
  mcMemory.prepareMerge();
  for (; mcMemory.getLangList(sLang); )
    mbLanguages.push_back(lang_container(sLang, sFile));

  XhpWrap::yylex();
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_xhp::setString(char *yytext)
{
  copySourceSpecial(yytext);
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_xhp::openTag(char *yytext)
{
  if (meExpectValue == VALUE_IS_VALUE)
  {
    meExpectValue  = VALUE_IS_VALUE_TAG;
    msCollector   += "\\";
  }
  copySourceSpecial(yytext);
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_xhp::closeTag(char *yytext)
{
  STATE newState = meExpectValue;

  switch (meExpectValue)
  {
    case VALUE_IS_VALUE_TAG:
         newState = VALUE_IS_VALUE;
         msCollector   += "\\";
         break;

    case VALUE_IS_TAG_TRANS:
         if (msKey.size())
           newState = VALUE_IS_VALUE;
         break;

    case VALUE_IS_TAG:
         msKey.clear();
         newState = VALUE_NOT_USED;
         break;
    case VALUE_NOT_USED:
    case VALUE_IS_VALUE:
         break;
  }
  copySourceSpecial(yytext);
  meExpectValue = newState;
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_xhp::setId(char *yytext)
{
  int          nL, nE;
  std::string& sText = copySourceSpecial(yytext);


  nL = sText.find("\"");
  nE = sText.find("\"", nL+1);
  if (nL == (int)std::string::npos || nE == (int)std::string::npos)
    return;

  switch (meExpectValue)
  {
    case VALUE_IS_TAG:
    case VALUE_IS_TAG_TRANS:
         msKey = sText.substr(nL+1, nE - nL -1) + msKey;
         break;

    case VALUE_IS_VALUE_TAG:
    case VALUE_NOT_USED:
    case VALUE_IS_VALUE:
         break;
  }
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_xhp::setLang(char *yytext)
{
  int          nL, nE;
  std::string  sLang;
  std::string& sText = copySourceSpecial(yytext, 1);


  nL = sText.find("\"");
  nE = sText.find("\"", nL+1);
  if (nL == (int)std::string::npos || nE == (int)std::string::npos)
    return;

  switch (meExpectValue)
  {
    case VALUE_IS_TAG:
         sLang = sText.substr(nL+1, nE - nL -1);
         if (sLang == "en-US")
           meExpectValue = VALUE_IS_TAG_TRANS;
         else
          mcMemory.showError(sLang + " is no en-US language");
         break;

    case VALUE_IS_VALUE_TAG:
         msCollector.erase(msCollector.size() - sText.size() -1);
         break;

    case VALUE_NOT_USED:
    case VALUE_IS_TAG_TRANS:
    case VALUE_IS_VALUE:
         break;
  }
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_xhp::setRef(char *yytext)
{
  int          nL, nE;
  std::string& sText = copySourceSpecial(yytext);


  nL = sText.find("\"");
  nE = sText.find("\"", nL+1);
  if (nL == (int)std::string::npos || nE == (int)std::string::npos)
    return;

  switch (meExpectValue)
  {
    case VALUE_IS_TAG:
    case VALUE_IS_TAG_TRANS:
         msKey += "." + sText.substr(nL+1, nE - nL -1);
         break;

    case VALUE_IS_VALUE_TAG:
    case VALUE_NOT_USED:
    case VALUE_IS_VALUE:
         break;
  }
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_xhp::openTransTag(char *yytext)
{
  copySourceSpecial(yytext);
  msKey.clear();
  meExpectValue = VALUE_IS_TAG;
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_xhp::closeTransTag(char *yytext)
{
  if (meExpectValue == VALUE_IS_VALUE || meExpectValue == VALUE_IS_VALUE_TAG)
  {
    if (msCollector.size() && msCollector != "-")
      mcMemory.setSourceKey(miLineNo, msSourceFile, msKey, msCollector);
    msKey.clear();
  }
  meExpectValue = VALUE_NOT_USED;
  copySourceSpecial(yytext, 2);
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_xhp::stopTransTag(char *yytext)
{
  copySourceSpecial(yytext);
  meExpectValue = VALUE_NOT_USED;
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_xhp::startComment(char *yytext)
{
  mePushValue   = meExpectValue;
  msPushCollect = msCollector;
  meExpectValue = VALUE_NOT_USED;
  copySourceSpecial(yytext);
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_xhp::stopComment(char *yytext)
{
  copySourceSpecial(yytext);
  meExpectValue = mePushValue;
  msCollector   = msPushCollect;
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_xhp::handleSpecial(char *yytext)
{
  int          nX    = msCollector.size();
  std::string& sText = copySourceSpecial(yytext);


  if (meExpectValue != VALUE_IS_VALUE || meExpectValue != VALUE_IS_VALUE_TAG)
  {
    msCollector.erase(nX);
    if      (sText == "&amp;")
      msCollector += "&";
    else if (sText == "&lt;")
      msCollector += "<";
    else if (sText == "&gt;")
      msCollector += ">";
    else if (sText == "&quot;")
      msCollector += "\"";
  }
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_xhp::handleDataEnd(char *yytext)
{
  int nX = msCollector.size();
  copySourceSpecial(yytext);

  if (meExpectValue == VALUE_IS_VALUE || meExpectValue == VALUE_IS_VALUE_TAG)
    msCollector.erase(nX);
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_xhp::duplicate(char *yytext)
{
  copySourceSpecial(yytext);

  if (meExpectValue == VALUE_IS_VALUE || meExpectValue == VALUE_IS_VALUE_TAG)
    msCollector += msCollector[msCollector.size()-1];
}



/**********************   I M P L E M E N T A T I O N   **********************/
std::string& convert_xhp::copySourceSpecial(char *yytext, int iType)
{
  iType = 0;
  return copySource(yytext, (meExpectValue != VALUE_IS_VALUE && meExpectValue != VALUE_IS_VALUE_TAG));


  // JIX tell copy source not to use outputfile
  // JIX write all languages sources.
}
