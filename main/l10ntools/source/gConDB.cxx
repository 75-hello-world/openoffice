/**************************************************************
 * 
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * 
 *************************************************************/
#include "gConDB.hxx"



/*****************************************************************************
 **************************   G C O N D B . C X X   **************************
 *****************************************************************************
 * This includes the c code generated by flex
 *****************************************************************************/



/************   I N T E R F A C E   I M P L E M E N T A T I O N   ************/
convert_db::convert_db(l10nMem& crMemory) : convert_gen_impl(crMemory) {}
convert_db::~convert_db()                                              {}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_db::execute()
{
  std::string newKey;
  int         i;


  msSourceBuffer   += '\n';
  miSize            = msSourceBuffer.size() -1;
  miLineNo          = 0;
  
  while (collectLine())
  {
    newKey = msFields[4];
    if (msFields[5].size())
      newKey += "." + msFields[5];
    if (msFields[3].size())
      newKey += "." + msFields[3];

    for (; (i = msFields[1].find('\\')) != std::string::npos;)
      msFields[1][i] = '/';

    // handle en_US or lang
    mcMemory.loadEntryKey(miLineNo, msFields[1], newKey, msFields[10], msFields[10], false);
  }
}


/**********************   I M P L E M E N T A T I O N   **********************/
bool convert_db::collectLine()
{
  int  i, iStart;
  bool bLineEnd;

  ++miLineNo;

  for (i = 0; i < NUMFIELD; ++i)
    msFields[i].clear();

  if (miSourceReadIndex >= miSize)
    return false;

  for (i = 0, bLineEnd = false, iStart = miSourceReadIndex; !bLineEnd; ++miSourceReadIndex)
  {
     if (msSourceBuffer[miSourceReadIndex] == '\r' ||    
         msSourceBuffer[miSourceReadIndex] == '\n' ||    
         miSourceReadIndex == miSize)    
       bLineEnd = true; 
     if (msSourceBuffer[miSourceReadIndex] == '\t' || bLineEnd)    
     {
       if (i >= NUMFIELD)
       {
         l10nMem::showError((char*)"TOO many fields", miLineNo);
       }
       msFields[i++] = msSourceBuffer.substr(iStart, miSourceReadIndex - iStart);
       iStart       = miSourceReadIndex +1;
     }
  }
  return true;
}
