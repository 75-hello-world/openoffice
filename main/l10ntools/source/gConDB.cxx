/**************************************************************
 * 
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * 
 *************************************************************/
#include "gConDB.hxx"



/*****************************************************************************
 **************************   G C O N D B . C X X   **************************
 *****************************************************************************
 * This includes the c code generated by flex
 *****************************************************************************/



/************   I N T E R F A C E   I M P L E M E N T A T I O N   ************/
convert_db::convert_db(l10nMem& crMemory) : convert_gen_impl(crMemory) {}
convert_db::~convert_db()                                              {}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_db::execute()
{
  std::string oldKey;
  int         iB, iE;


  msSourceBuffer   += '\n';
  miSize            = msSourceBuffer.size() -1;
  miLineNo          = 0;
  
  while (collectLine())
  {
    mcMemory.setFileName(0, msFields[1], true);
    if (mbMergeMode)
    {
      iB = msFields[15].find("/");
      if (iB == (int)std::string::npos)
        mcMemory.showError((char*)"missing / in en_US", miLineNo);
      iE = msFields[15].find("/", iB+1);
      if (iE == (int)std::string::npos)
        mcMemory.showError((char*)"missing / in en_US", miLineNo);
      oldKey = msFields[15].substr(iB+1, iE - iB -1);
      iB = msFields[15].find("/",iE+1);
      if (iB == (int)std::string::npos)
        mcMemory.showError((char*)"missing / in en_US", miLineNo);
      if (iB != iE+1)
        oldKey += "." + msFields[15].substr(iE+1, iB - iE -1);

      // handle en-US (master)
//JIX      mcMemory.loadEnUsKey(msFields[4], msFields[3], msFields[10], oldKey);
    }
    else
    {
      std::string newKey = msFields[4];
      if (msFields[5].size())
        newKey += "." + msFields[5];
//JIX      mcMemory.loadLangKey(msFields[9], newKey, msFields[3], msFields[10]);
    }
 }
}


/**********************   I M P L E M E N T A T I O N   **********************/
bool convert_db::collectLine()
{
  int  i, iStart;
  bool bLineEnd;

  ++miLineNo;

  for (i = 0; i < NUMFIELD; ++i)
    msFields[i].clear();

  if (miSourceReadIndex >= miSize)
    return false;

  for (i = 0, bLineEnd = false, iStart = miSourceReadIndex; !bLineEnd; ++miSourceReadIndex)
  {
     if (msSourceBuffer[miSourceReadIndex] == '\r' ||    
         msSourceBuffer[miSourceReadIndex] == '\n' ||    
         miSourceReadIndex == miSize)    
       bLineEnd = true; 
     if (msSourceBuffer[miSourceReadIndex] == '\t' || bLineEnd)    
     {
       if (i >= NUMFIELD)
       {
         mcMemory.showError((char*)"TOO many fields", miLineNo);
       }
       msFields[i++] = msSourceBuffer.substr(iStart, miSourceReadIndex - iStart);
       iStart       = miSourceReadIndex +1;
     }
  }
  return true;
}
